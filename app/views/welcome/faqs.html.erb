
<h1>FAQs</h1>

<div id="generated-toc"></div>

<h2>What is autoEdit?</h2>

<p>It’s a digital paper editing software. For those less familiar with it, a paper edit is a script made from a selection of lines from the transcriptions of interviews.</p>

<!-- pop over tooltip code from bootstrap-->
<script>
$(function () {
  $('[data-toggle="popover"]').popover()
})
</script>
<!-- pop over end -->



<p>With autoEdit, you can analyse your transcripts and mark them with tags and create a paper edit, &nbsp;that you can then export as an <button type="text" class="btn btn-sm btn-link" data-toggle="popover" title="What is an EDL?" data-content="EDL Stands for Edit Decision List, and is an internchange file format, mostly used to move a project to or from a different system or editing workstation. A bit like XML but contains less information.">EDL</button>. You can then open in the editing software of your choice to reconnect the corresponding video into a sequence, and finish working on your rough-cut assembly.</p>

<p>For the transcriptions, autoEdit, takes <code>.sbv</code> and <code>.srt</code> subtitles files, and the suggested workflow is to use YouTube semi-automated captioning, to get a first draft of the timecoded transcriptions, that you can then proofread. Google/YouTube is very accurate at putting timecodes at the end of sentences, which is one less thing to do.</p>

<h2>How does it work?</h2>

<p><strong>Preparation</strong></p>
<ul>
	<li>get your transcriptions done in <code>.sbv</code> or <code>.srt</code> subtitle file format, for instance using <a href="https://support.google.com/youtube/topic/3014331?hl=en&ref_topic=4355241" target="_blank">YouTube automated captions</a></li>
</ul>

<p><strong>In autoEdit</strong></p>

<ul>
	<li>upload transcripts in autoEdit, with metadata info of corresponding video</li>
	<li>search and filter, drag and drop your selections into a new paper edit</li>
	<li>export as EDL </li>
</ul>
<p><strong>In editing software</strong></p>
<ul>
	<li>open EDL in editing software of choice</li>
	<li>continue editing your sequence</li>
</ul>

<h2>I don’t want to use YouTube captioning - can I still use autoEdit?</h2>

<p>Yes, as long as you can get your transcriptions into <code>.sbv</code> or <code>.srt</code>  files then you are good to go. </p>

<p>A tool we recommend for getting your transcriptions done in  <code>.sbv</code> or <code>.srt</code>  is <a href="http://www.nikse.dk/subtitleedit/" target="_blank">Subtitle Edit</a>.</p>

<h2>Can the transcription only be <code>.sbv</code> or <code>.srt</code> subtitles files?</h2>

<p>Yes, for now, but if you have transcriptions in formats other than <code>.sbv</code> or <code>.srt</code> <a href="mailto:info@autoedit.io?subject=autoEdit%20Subtiles%20File%20Format%20Enquiry
&body=Hello,%0D%0A I have a quesiton about autoEdit subtitles file formats support..">we want to hear from you</a>.</p>

<h2>Which languages are supported?</h2>

<p>If you use Google/YouTube captions, to generate semi-automated transcriptions then the languages supported are: </p>

<p>• English</p>

<p>• Dutch</p>

<p>• French</p>

<p>• German</p>

<p>• Italian</p>

<p>• Japanese</p>

<p>• Korean</p>

<p>• Portuguese</p>

<p>• Russian</p>

<p>• Spanish</p>

<p>See <a href="https://support.google.com/youtube/topic/3014331?hl=en&ref_topic=4355241" target="_blank">Google Automatic captions</a> for more details, and an up to date list of languages.</p>

<p>Having said that, autoEdit itself is language-independent, as long as you can get an <code>.sbv</code>,<code>.srt</code> file of the transcriptions.</p>

<h2>I am working with different languages, is there support for that?</h2>

<p>At the moment there is a work around that can still save you a lot of time. You can use YouTube/Google automated captions to get the transcription in the language you want (if supported, see list, otherwise, there are alternative methods to get your transcriptions done in <code>.sbv</code> or <code>.srt</code> formats, using autoEdit).</p>

<p>Then you can use the <a href="https://translate.google.com/toolkit" target="_blank">google translator toolkit</a>, to translate your <code>.sbv</code>/<code>.srt</code> file into the required language to get a semi automated translation. </p>

<p>The translation file can then be uploaded into autoEdit in <code>.sbv</code>/<code>.srt</code> format. After paper editing, you can then export the EDL and reconnect and the rough cut will be as accurate as the translations you have put in it.</p>

<p>You can then export the rough cut video sequence from your editing software as a video preview for proof checking.</p>

<p>There are ways in which autoEdit could support this, so if this is a feature you would be interested in please do get in touch.</p>


<h2 id="metadata">I am uploading a transcript, how do I get the <code>filename</code>, <code>reel</code> and <code>media start</code> for the camera metadata section? </h2>


<p>We need the <code>filename</code>, <code>reel</code> and <code>Media Start</code> as it appears in the metadata of the video file.</p>

<p>For instance In Final Cut Pro 7</p>
<p>1. Find the clip in the inspector view, top left panel</p>
<p>2. Rigth click the clip in the inspector view, top left panel</p>
<p>3. Choose <code> item proprieties</code> -> <code>logging info</code></p>

<%= image_tag "loggingInfo.png", class: "img-responsive" %>
<p>4. in the <code>logging</code> tab, you'll find the first 3 fields are <code>Name</code>(filename), <code>Reel</code> and <code>Media Start</code></p>
<%= image_tag "fileNameReelNameMediaStart.png", class: "img-responsive" %>

<p>5. The only adjustment to make is that for the filename <code>Name</code> we need it with the <code>.mov</code> extension.</p> 

<p>For instance if I were to take the file <code>Name</code> from the example it would be <code>CC027_01.mov</code> </p>

<p>6. If the <code>Reel</code> name is blank, which could be for a number of reasons, such as working with footage from the Internet, or DSLRs, then in this field you can add a reel name, and it will prompt you to save it to disk, and write the metadata onto the actual file. </p><p>To use autoEdi, your video file needs to have a reel name, otherwise the exported EDL will not be have enough informations on it to be able to reconnect the sequence in the editing software of choie.</p> 
<br>
<p>For any questions: 
<a href="mailto:info@autoedit.io?subject=autoEdit%20Metadata%20Enquiry
&body=Hello,%0D%0A I am trying to upload a transcript in autoEdit and I am having trouble with identifying the metadata..">info@autoedit.io</a></p>



<br><br><br><br><br><br>

<script>
/** Generated TOC
    Stuart Langridge, July 2007
    
    Generate a table of contents, based on headings in the page.
    
    To place the TOC on the page, add
    
    <div id="generated-toc"></div>
    
    to the page where you want the TOC to appear. If this element
    is not present, the TOC will not appear.
    
    The TOC defaults to displaying all headings that are contained within
    the same element as it itself is contained in (or all headings on the
    page if you did not provide a generated-toc container). To override this,
    provide a "highest heading" value by adding class="generate_from_h3"
    (or h2, h4, etc) to the container. (If unspecified, this will display all
    headings, as if class="generate_from_h1" was specified.)
    
    The TOC defaults to operating only on headings contained within the same
    element as it itself, i.e., in a page like this:
    
    <div>
      <div>
        <div id="generated-toc"></div>
        <h1>foo</h1>
        <h2>bar</h2>
      </div>
      <h1>quux</h1>
    </div>
    
    The "quux" heading will not appear in the TOC. To override this,
    add class="generate_for_page" to the container, which will process
    all headings on the page wheresoever they may be.

*/

generated_toc = {
  generate: function() {
    // Identify our TOC element, and what it applies to
    generate_from = '0';
    generate_for = 'unset';
    tocparent = document.getElementById('generated-toc');
    if (tocparent) {
      // there is a div class="generated-toc" in the document
      // dictating where the TOC should appear
      classes = tocparent.className.split(/\s+/);
      for (var i=0; i<classes.length; i++) {
        // if it specifies which heading level to generate from,
        // or what level to generate for, save these specifications
        if (classes[i].match(/^generate_from_h[1-6]$/)) {
          generate_from = classes[i].substr(classes[i].length-1,1);
        } else if (classes[i].match(/^generate_for_[a-z]+$/)) {
          generate_for = classes[i].match(/^generate_for_([a-z])+$/)[1];
        }
      }
    } else {
      // They didn't specify a TOC element; exit
      return;
    }
    
    // set top_node to be the element in the document under which
    // we'll be analysing headings
    if (generate_for == 'page') {
      top_node = document.getElementsByTagName('body');
    } else {
      // i.e., explicitly set to "parent", left blank (so "unset"),
      // or some invalid value
      top_node = tocparent.parentNode;
    }
    
    // If there isn't a specified header level to generate from, work
    // out what the first header level inside top_node is
    // and make that the specified header level
    if (generate_from == 0) {
      first_header_found = generated_toc.findFirstHeader(top_node);
      if (!first_header_found) {
        // there were no headers at all inside top_node!
        return;
      } else {
        generate_from = first_header_found.toLowerCase().substr(1);
      }
    }
    
    // add all levels of heading we're paying attention to to the
    // headings_to_treat dictionary, ready to be filled in later
    headings_to_treat = {"h6":''};
    for (var i=5; i>= parseInt(generate_from); i--) {
      headings_to_treat["h" + i] = '';
    }
    
    // get headings. We can't say 
    // getElementsByTagName("h1" or "h2" or "h3"), etc, so get all
    // elements and filter them ourselves
    // need to use .all here because IE doesn't support gEBTN('*')
    nodes = top_node.all ? top_node.all : top_node.getElementsByTagName('*');
    
    // put all the headings we care about in headings
    headings = [];
    for (var i=0; i<nodes.length;i++) {
      if (nodes[i].nodeName.toLowerCase() in headings_to_treat) {
        // if heading has class no-TOC, skip it
        if ((' ' + nodes[i].className + ' ').indexOf('no-TOC') != -1) {
          continue;
        }
        headings.push(nodes[i]);
      }
    }
    
    // make the basic elements of the TOC itself, ready to fill into
    
    // first, check if there's a cookie defined to save the state as open
    status = generated_toc.readCookie("generated_toc_display");
    if (status && status == "open") {
      display_initially = "block";
      toggle_initially = "Hide table of contents";
    } else {
      display_initially = "none";
      toggle_initially = "Show table of contents";
    }

    cur_head_lvl = "h" + generate_from;
    cur_list_el = document.createElement('ul');
    cur_list_el.style.display = display_initially;
    p = document.createElement('p');
    span = document.createElement('span');
    span.className = 'hidden';
    a = document.createElement('a');
    a.href = '#aftertoc';
    a.appendChild(document.createTextNode('skip table of contents'));
    span.appendChild(a);
    p.appendChild(span);
    tocparent.appendChild(p);
    p = document.createElement('p');
    p.id = 'toggle-container'; 
    a = document.createElement('a');
    a.id = 'generated_toc_d_toggle';
    a.appendChild(document.createTextNode(toggle_initially));
    p.appendChild(a);
    a.onclick = generated_toc.wrapOpenClose(a,cur_list_el);
    a.href = '#';
    tocparent.appendChild(p);
    tocparent.appendChild(cur_list_el);
    
    // now walk through our saved heading nodes
    for (var i=0; i<headings.length; i++) {
      this_head_el = headings[i];
      this_head_lvl = headings[i].nodeName.toLowerCase();
      if (!this_head_el.id) {
        // if heading doesn't have an ID, give it one
        this_head_el.id = 'heading_toc_j_' + i;
        this_head_el.setAttribute('tabindex','-1');
      }
      
      while(this_head_lvl > cur_head_lvl) {
        // this heading is at a lower level than the last one;
        // create additional nested lists to put it at the right level

        // get the *last* LI in the current list, and add our new UL to it
        var last_listitem_el = null;
        for (var j=0; j<cur_list_el.childNodes.length; j++) {
          if (cur_list_el.childNodes[j].nodeName.toLowerCase() == 'li') {
            last_listitem_el = cur_list_el.childNodes[j];
          }
        }
        if (!last_listitem_el) {
          // there aren't any LIs, so create a new one to add the UL to
          last_listitem_el = document.createElement('li');
        }
        new_list_el = document.createElement('ul');
        last_listitem_el.appendChild(new_list_el);
        cur_list_el.appendChild(last_listitem_el);
        cur_list_el = new_list_el;
        cur_head_lvl = 'h' + (parseInt(cur_head_lvl.substr(1,1)) + 1);
      }
      
      while (this_head_lvl < cur_head_lvl) {
        // this heading is at a higher level than the last one;
        // go back up the TOC to put it at the right level
        cur_list_el = cur_list_el.parentNode.parentNode;
        cur_head_lvl = 'h' + (parseInt(cur_head_lvl.substr(1,1)) - 1);
      }
      
      // create a link to this heading, and add it to the TOC
      li = document.createElement('li');
      a = document.createElement('a');
      a.href = '#' + this_head_el.id;
      a.appendChild(document.createTextNode(generated_toc.innerText(this_head_el)));
      li.appendChild(a);
      cur_list_el.appendChild(li);
    }
    
    // add an aftertoc paragraph as destination for the skip-toc link
    p = document.createElement('p');
    p.id = 'aftertoc';
    tocparent.appendChild(p);
    
    // go through the TOC and find all LIs that are "empty", i.e., contain
    // only ULs and no links, and give them class="missing"
    var alllis = tocparent.getElementsByTagName("li");
    for (var i=0; i<alllis.length; i++) {
      var foundlink = false;
      for (var j=0; j<alllis[i].childNodes.length; j++) {
        if (alllis[i].childNodes[j].nodeName.toLowerCase() == 'a') {
          foundlink = true;
        }
      }
      if (!foundlink) {
        alllis[i].className = "missing";
      } else {
        alllis[i].className = "notmissing";
      }
    }
    
  },
  
  wrapOpenClose: function(a, cur_list_el) {
    // we return a function here so that it acts as a closure;
    // in essence the inner function, which is the event handler
    // for clicking on the toggle-toc link, remembers the a and cur_list_el
    // elements as they are when they're passed in to it.
    // This is an explicit function rather than an anonymous function
    // defined where it's called so it's easier to understand.
    return function(e) {
      d = cur_list_el.style.display;
      a.firstChild.nodeValue = (d == 'block' ? 'Show' : 'Hide') + ' table of contents';
      a.className = (d == 'block' ? 'toggle-closed' : 'toggle-open'); 
      cur_list_el.style.display = d == 'block' ? 'none' : 'block';
      // set a cookie to "open" or "closed" to save the state of the TOC
      if (cur_list_el.style.display == "block") {
        generated_toc.createCookie("generated_toc_display","open",21);
      } else {
        generated_toc.createCookie("generated_toc_display","closed",21);
      }
      if (window.event) {
        window.event.returnValue = false;
        window.event.cancelBubble = true;
      } else {
        e.preventDefault();
        e.stopPropagation();
      }
    }
  },
  
  /* cookie handling: http://www.quirksmode.org/js/cookies.html */
  createCookie: function(name,value,days) {
    if (days) {
      var date = new Date();
      date.setTime(date.getTime()+(days*24*60*60*1000));
      var expires = "; expires="+date.toGMTString();
    }
    else var expires = "";
    document.cookie = name+"="+value+expires+"; path=/";
  },

  readCookie: function(name) {
    var nameEQ = name + "=";
    var ca = document.cookie.split(';');
    for(var i=0;i < ca.length;i++) {
      var c = ca[i];
      while (c.charAt(0)==' ') c = c.substring(1,c.length);
      if (c.indexOf(nameEQ) == 0) 
        return c.substring(nameEQ.length,c.length);
    }
    return null;
  },

  eraseCookie: function(name) {
    createCookie(name,"",-1);
  },  
  
  innerText: function(el) {
    return (typeof(el.innerText) != 'undefined') ? el.innerText :
          (typeof(el.textContent) != 'undefined') ? el.textContent :
          el.innerHTML.replace(/<[^>]+>/g, '');
  },
  
  findFirstHeader: function(node) {
    // a recursive function which returns the first header it finds inside
    // node, or null if there are no functions inside node.
    var nn = node.nodeName.toLowerCase();
    if (nn.match(/^h[1-6]$/)) {
      // this node is itself a header; return our name
      return nn;
    } else {
      for (var i=0; i<node.childNodes.length; i++) {
        var subvalue = generated_toc.findFirstHeader(node.childNodes[i]);
        // if one of the subnodes finds a header, abort the loop and return it
        if (subvalue) return subvalue;
      }
      // no headers in this node at all
      return null;
    }
  },

  init: function() {
    // quit if this function has already been called
    if (arguments.callee.done) return;

    // flag this function so we don't do the same thing twice
    arguments.callee.done = true;

    generated_toc.generate();
  }
};

(function(i) {var u =navigator.userAgent;var e=/*@cc_on!@*/false; var st =
setTimeout;if(/webkit/i.test(u)){st(function(){var dr=document.readyState;
if(dr=="loaded"||dr=="complete"){i()}else{st(arguments.callee,10);}},10);}
else if((/mozilla/i.test(u)&&!/(compati)/.test(u)) || (/opera/i.test(u))){
document.addEventListener("DOMContentLoaded",i,false); } else if(e){     (
function(){var t=document.createElement('doc:rdy');try{t.doScroll('left');
i();t=null;}catch(e){st(arguments.callee,0);}})();}else{window.onload=i;}})(generated_toc.init);



</script>
